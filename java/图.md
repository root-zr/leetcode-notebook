## 图



### DFS

#### [2646. 最小化旅行的价格总和](https://leetcode.cn/problems/minimize-the-total-price-of-the-trips/)

现有一棵无向、无根的树，树中有 `n` 个节点，按从 `0` 到 `n - 1` 编号。给你一个整数 `n` 和一个长度为 `n - 1` 的二维整数数组 `edges` ，其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间存在一条边。

每个节点都关联一个价格。给你一个整数数组 `price` ，其中 `price[i]` 是第 `i` 个节点的价格。

给定路径的 **价格总和** 是该路径上所有节点的价格之和。

另给你一个二维整数数组 `trips` ，其中 `trips[i] = [starti, endi]` 表示您从节点 `starti` 开始第 `i` 次旅行，并通过任何你喜欢的路径前往节点 `endi` 。

在执行第一次旅行之前，你可以选择一些 **非相邻节点** 并将价格减半。

返回执行所有旅行的最小价格总和。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2023/03/16/diagram2.png)

> 输入：n = 4, edges = [[0,1],[1,2],[1,3]], price = [2,2,10,6], trips = [[0,3],[2,1],[2,3]]
> 输出：23
> 解释：
> 上图表示将节点 2 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 、2 和 3 并使其价格减半后的树。
> 第 1 次旅行，选择路径 [0,1,3] 。路径的价格总和为 1 + 2 + 3 = 6 。
> 第 2 次旅行，选择路径 [2,1] 。路径的价格总和为 2 + 5 = 7 。
> 第 3 次旅行，选择路径 [2,1,3] 。路径的价格总和为 5 + 2 + 3 = 10 。
> 所有旅行的价格总和为 6 + 7 + 10 = 23 。可以证明，23 是可以实现的最小答案。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2023/03/16/diagram3.png)

> 输入：n = 2, edges = [[0,1]], price = [2,2], trips = [[0,0]]
> 输出：1
> 解释：
> 上图表示将节点 0 视为根之后的树结构。第一个图表示初始树，第二个图表示选择节点 0 并使其价格减半后的树。 
> 第 1 次旅行，选择路径 [0] 。路径的价格总和为 1 。 
> 所有旅行的价格总和为 1 。可以证明，1 是可以实现的最小答案。

 

**提示：**

- `1 <= n <= 50`
- `edges.length == n - 1`
- `0 <= ai, bi <= n - 1`
- `edges` 表示一棵有效的树
- `price.length == n`
- `price[i]` 是一个偶数
- `1 <= price[i] <= 1000`
- `1 <= trips.length <= 100`
- `0 <= starti, endi <= n - 1`

```
class Solution {
    ArrayList<Integer>[] graph;
    public boolean path(int x, int father, int end, int[] cnt) {
        if (x == end) {
            cnt[x]++;
            return true;
        }

        ArrayList<Integer> list = graph[x];
        for (int i = 0; i < list.size(); i++) {
            int y = list.get(i);
            if (y == father) {
                continue;
            }
            boolean isPathConnect = path(y, x, end, cnt);
            if (!isPathConnect) {
                continue;
            }
            
            cnt[x]++;
            return true;
        }
        return false;
    }

    public Node dfs(int x, int father, int[] price, int[] cnt) {
        int notHalf = price[x] * cnt[x];
        int half = price[x] * cnt[x] / 2;
        for (int i = 0; i < graph[x].size(); i++) {
            int y = graph[x].get(i);
            if (y == father) {
                continue;
            }
            Node node = dfs(y, x, price, cnt);
            notHalf += Math.min(node.halfVal, node.notHalfVal); // 如果 x 不减半, y 可以减半也可以不减
            half += node.notHalfVal; // 如果 x 减半, y 只能不减半
        }
        return new Node(notHalf, half);
    }

    public int minimumTotalPrice(int n, int[][] edges, int[] price, int[][] trips) {
        graph = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }

        int[] cnt = new int[n]; // 统计每个点在所有的trips里经过了多少次
        for (int[] trip : trips) {
            path(trip[0], -1, trip[1], cnt);
        }

        Node ans = dfs(0, -1, price, cnt);
        return Math.min(ans.halfVal, ans.notHalfVal);
    }
}

class Node {
    int notHalfVal;
    int halfVal;

    public Node(int notHalfVal, int halfVal) {
        this.notHalfVal = notHalfVal;
        this.halfVal = halfVal;
    }
}
```

#### [2596. 检查骑士巡视方案](https://leetcode.cn/problems/check-knight-tour-configuration/)

骑士在一张 `n x n` 的棋盘上巡视。在有效的巡视方案中，骑士会从棋盘的 **左上角** 出发，并且访问棋盘上的每个格子 **恰好一次** 。

给你一个 `n x n` 的整数矩阵 `grid` ，由范围 `[0, n * n - 1]` 内的不同整数组成，其中 `grid[row][col]` 表示单元格 `(row, col)` 是骑士访问的第 `grid[row][col]` 个单元格。骑士的行动是从下标 **0** 开始的。

如果 `grid` 表示了骑士的有效巡视方案，返回 `true`；否则返回 `false`。

**注意**，骑士行动时可以垂直移动两个格子且水平移动一个格子，或水平移动两个格子且垂直移动一个格子。下图展示了骑士从某个格子出发可能的八种行动路线。
![img](https://assets.leetcode.com/uploads/2018/10/12/knight.png)

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-5.png)

> 输入：grid = [[0,11,16,5,20],[17,4,19,10,15],[12,1,8,21,6],[3,18,23,14,9],[24,13,2,7,22]]
> 输出：true
> 解释：grid 如上图所示，可以证明这是一个有效的巡视方案。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/12/28/yetgriddrawio-6.png)

> 输入：grid = [[0,3,6],[5,8,1],[2,7,4]]
> 输出：false
> 解释：grid 如上图所示，考虑到骑士第 7 次行动后的位置，第 8 次行动是无效的。

 

**提示：**

- `n == grid.length == grid[i].length`
- `3 <= n <= 7`
- `0 <= grid[row][col] < n * n`
- `grid` 中的所有整数 **互不相同**

```
class Solution {
    public boolean backTrack(int[][] grid, int i, int x, int y) {
        if (x < 0 || x >= grid.length || y < 0 || y >= grid.length) {
            return false;
        }
        
        if (grid[x][y] != i) {
            return false;
        }
        
        if (i == grid.length * grid.length - 1) {
            return true;
        }
        
        int[] arrX = new int[]{-2, -1, -2, -1, 1, 2, 1, 2};
        int[] arrY = new int[]{1, 2, -1, -2, 2, 1, -2, -1};
        
        boolean res = false;
        for (int j = 0; j < arrX.length; j++) {
            res |= backTrack(grid, i + 1, x + arrX[j], y + arrY[j]);
        }
        
        return res;
    }
    public boolean checkValidGrid(int[][] grid) {
        return backTrack(grid, 0, 0, 0);
    }
}
```

#### [2556. 二进制矩阵中翻转最多一次使路径不连通](https://leetcode.cn/problems/disconnect-path-in-a-binary-matrix-by-at-most-one-flip/)

给你一个下标从 **0** 开始的 `m x n` **二进制** 矩阵 `grid` 。你可以从一个格子 `(row, col)` 移动到格子 `(row + 1, col)` 或者 `(row, col + 1)` ，前提是前往的格子值为 `1` 。如果从 `(0, 0)` 到 `(m - 1, n - 1)` 没有任何路径，我们称该矩阵是 **不连通** 的。

你可以翻转 **最多一个** 格子的值（也可以不翻转）。你 **不能翻转** 格子 `(0, 0)` 和 `(m - 1, n - 1)` 。

如果可以使矩阵不连通，请你返回 `true` ，否则返回 `false` 。

**注意** ，翻转一个格子的值，可以使它的值从 `0` 变 `1` ，或从 `1` 变 `0` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/12/07/yetgrid2drawio.png)

> 输入：grid = [[1,1,1],[1,0,0],[1,1,1]]
> 输出：true
> 解释：按照上图所示我们翻转蓝色格子里的值，翻转后从 (0, 0) 到 (2, 2) 没有路径。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/12/07/yetgrid3drawio.png)

> 输入：grid = [[1,1,1],[1,0,1],[1,1,1]]
> 输出：false
> 解释：无法翻转至多一个格子，使 (0, 0) 到 (2, 2) 没有路径。

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 1000`
- `1 <= m * n <= 105`
- `grid[0][0] == grid[m - 1][n - 1] == 1`

```
class Solution {
    public boolean isConvertValid(int row, int col, int m, int n) {
        if (row == 0 && col == 0) {
            return false;
        }
        if (row == m - 1 && col == n - 1) {
            return false;
        }
        return true;
    }
    public boolean dfs(int[][] grid, int row, int col) {
        int m = grid.length;
        int n = grid[0].length;
        if (row < 0 || row >= m || col < 0 || col >= n) {
            return false;
        }

        if (grid[row][col] == 0) {
            return false;
        }
        if (isConvertValid(row, col, m, n)) {
            grid[row][col] = 0;
        }
        
        if (row == m - 1 && col == n - 1) {
            return true;
        }

        return dfs(grid, row + 1, col) || dfs(grid, row, col + 1);       
    }

    public boolean isPossibleToCutPath(int[][] grid) {
        if (!dfs(grid, 0, 0)) { // 本身就不通
            return true;
        }

        // 连续两次dfs判断两条路径有没有交集，如果有，说明反转这个交集就可以不连通
        return !dfs(grid, 0, 0);
    }
}
```



### BFS



#### [1091. 二进制矩阵中的最短路径](https://leetcode.cn/problems/shortest-path-in-binary-matrix/)

给你一个 `n x n` 的二进制矩阵 `grid` 中，返回矩阵中最短 **畅通路径** 的长度。如果不存在这样的路径，返回 `-1` 。

二进制矩阵中的 畅通路径 是一条从 **左上角** 单元格（即，`(0, 0)`）到 右下角 单元格（即，`(n - 1, n - 1)`）的路径，该路径同时满足下述要求：

- 路径途经的所有单元格都的值都是 `0` 。
- 路径中所有相邻的单元格应当在 **8 个方向之一** 上连通（即，相邻两单元之间彼此不同且共享一条边或者一个角）。

**畅通路径的长度** 是该路径途经的单元格总数。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2021/02/18/example1_1.png)

> 输入：grid = [[0,1],[1,0]]
> 输出：2

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/02/18/example2_1.png)

> 输入：grid = [[0,0,0],[1,1,0],[1,1,0]]
> 输出：4

**示例 3：**

> 输入：grid = [[1,0,0],[1,1,0],[1,1,0]]
> 输出：-1

 

**提示：**

- `n == grid.length`
- `n == grid[i].length`
- `1 <= n <= 100`
- `grid[i][j]` 为 `0` 或 `1`

```
class Solution {
    int ans;
    int[][] paths = new int[][]{{1, 0}, {-1, 0}, {0, 1}, {0, -1}, {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};

    public int shortestPathBinaryMatrix(int[][] grid) {
        if (grid[0][0] == 1) {
            return -1;
        }

        Queue<Pair> que = new LinkedList<>();
        que.add(new Pair(0, 0, 0));

        while (!que.isEmpty()) {
            Pair pair = que.poll();
            int x = pair.x;
            int y = pair.y;
            int newCnt = pair.cnt + 1;

            if (x == grid.length - 1 && y == grid[0].length - 1) {
                return newCnt;
            }

            for (int[] path : paths) {
                int newX = x + path[0];
                int newY = y + path[1];
                
                if (newX < 0 || newX >= grid.length || newY < 0 ||
                    newY >= grid[0].length || grid[newX][newY] == 1) {
                    continue;
                }
  
                que.add(new Pair(newX, newY, newCnt));
                grid[newX][newY] = 1;
            }
        }

        return -1;
    }
}

class Pair {
    int x;
    int y;
    int cnt;

    public Pair(int x, int y, int cnt) {
        this.x = x;
        this.y = y;
        this.cnt = cnt;
    }
}
```



### 拓扑排序

#### [207. 课程表](https://leetcode-cn.com/problems/course-schedule/)

你这个学期必须选修 `numCourses` 门课程，记为 `0` 到 `numCourses - 1` 。

在选修某些课程之前需要一些先修课程。 先修课程按数组 `prerequisites` 给出，其中 `prerequisites[i] = [ai, bi]` ，表示如果要学习课程 `ai` 则 **必须** 先学习课程 `bi` 。

- 例如，先修课程对 `[0, 1]` 表示：想要学习课程 `0` ，你需要先完成课程 `1` 。

请你判断是否可能完成所有课程的学习？如果可以，返回 `true` ；否则，返回 `false` 。 

**示例 1：**

> 输入：numCourses = 2, prerequisites = [[1,0]]
> 输出：true
> 解释：总共有 2 门课程。学习课程 1 之前，你需要完成课程 0 。这是可能的。

**示例 2：**

> 输入：numCourses = 2, prerequisites = [[1,0],[0,1]]
> 输出：false
> 解释：总共有 2 门课程。学习课程 1 之前，你需要先完成课程 0 ；并且学习课程 0 之前，你还应先完成课程 1 。这是不可能的。

**提示：**

- `1 <= numCourses <= 105`
- `0 <= prerequisites.length <= 5000`
- `prerequisites[i].length == 2`
- `0 <= ai, bi < numCourses`
- `prerequisites[i]` 中的所有课程对 **互不相同**

全部采用邻接表来存放图的信息。采用深度和广度优先两种遍历方式。

```java
//深度优先，拓扑排序
class Solution {
    List<List<Integer>> edges;
    int[] visited;  
    boolean valid = true;

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>();
        for (int i = 0; i < numCourses; ++i) {
            edges.add(new ArrayList<Integer>());
        }
        visited = new int[numCourses];
        for (int[] info : prerequisites) {
            edges.get(info[1]).add(info[0]);
        }
        for (int i = 0; i < numCourses && valid; ++i) {
            if (visited[i] == 0) {
                dfs(i);
            }
        }
        return valid;
    }

    public void dfs(int u) {
        visited[u] = 1;
        for (int v: edges.get(u)) {
            if (visited[v] == 0) {
                dfs(v);
                if (!valid) {
                    return;
                }
            } else if (visited[v] == 1) {
                valid = false;
                return;
            }
        }
        visited[u] = 2;
    }
}
```

```java
//广度优先遍历
class Solution {
    List<List<Integer>> edges;
    int[] indeg;  //存放每个结点入度的信息

    public boolean canFinish(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>();
        for (int i = 0; i < numCourses; ++i) {
            edges.add(new ArrayList<Integer>());
        }
        indeg = new int[numCourses];
        for (int[] info : prerequisites) {
            edges.get(info[1]).add(info[0]);
            ++indeg[info[0]];
        }

        Queue<Integer> queue = new LinkedList<Integer>();
        for (int i = 0; i < numCourses; ++i) {
            if (indeg[i] == 0) {
                queue.offer(i);
            }
        }

        int visited = 0;
        while (!queue.isEmpty()) {
            ++visited;
            int u = queue.poll();
            for (int v: edges.get(u)) {
                --indeg[v];
                if (indeg[v] == 0) {
                    queue.offer(v);
                }
            }
        }

        return visited == numCourses;
    }
}
```

#### [210. 课程表 II](https://leetcode-cn.com/problems/course-schedule-ii/)

现在你总共有 *n* 门课需要选，记为 `0` 到 `n-1`。

在选修某些课程之前需要一些先修课程。 例如，想要学习课程 0 ，你需要先完成课程 1 ，我们用一个匹配来表示他们: [0,1]

给定课程总量以及它们的先决条件，返回你为了学完所有课程所安排的学习顺序。

可能会有多个正确的顺序，你只要返回一种就可以了。如果不可能完成所有课程，返回一个空数组。

**示例 1:**

> 输入: 2, [[1,0]] 
> 输出: [0,1]
> 解释: 总共有 2 门课程。要学习课程 1，你需要先完成课程 0。因此，正确的课程顺序为 [0,1] 。

**示例 2:**

> 输入: 4, [[1,0],[2,0],[3,1],[3,2]]
> 输出: [0,1,2,3] or [0,2,1,3]
> 解释: 总共有 4 门课程。要学习课程 3，你应该先完成课程 1 和课程 2。并且课程 1 和课程 2 都应该排在课程 0 之后。
>      因此，一个正确的课程顺序是 [0,1,2,3] 。另一个正确的排序是 [0,2,1,3] 。

**说明:**

1. 输入的先决条件是由**边缘列表**表示的图形，而不是邻接矩阵。详情请参见[图的表示法](http://blog.csdn.net/woaidapaopao/article/details/51732947)。
2. 你可以假定输入的先决条件中没有重复的边。

**提示:**

1. 这个问题相当于查找一个循环是否存在于有向图中。如果存在循环，则不存在拓扑排序，因此不可能选取所有课程进行学习。
2. [通过 DFS 进行拓扑排序](https://www.coursera.org/specializations/algorithms) - 一个关于Coursera的精彩视频教程（21分钟），介绍拓扑排序的基本概念。
3. 拓扑排序也可以通过 [BFS](https://baike.baidu.com/item/宽度优先搜索/5224802?fr=aladdin&fromid=2148012&fromtitle=广度优先搜索) 完成。

```java
class Solution {
   
    List<List<Integer>> edges;
    int[] visited;
    int[] result;
    // 判断有向图中是否有环
    boolean valid = true;
    
    int index; // 数组下标，深度优先最先找出来的应该是最后要学的课程，所以要采用逆序的方式打印

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>();
        for (int i = 0; i < numCourses; ++i) {
            edges.add(new ArrayList<Integer>());
        }
        visited = new int[numCourses];
        result = new int[numCourses];
        index = numCourses - 1;
        for (int[] info : prerequisites) {
            edges.get(info[1]).add(info[0]);
        }
       
        for (int i = 0; i < numCourses && valid; ++i) {
            if (visited[i] == 0) {
                dfs(i);
            }
        }
        if (!valid) {
            return new int[0];
        }
       
        return result;
    }

    public void dfs(int u) {
      
        visited[u] = 1;
    
        for (int v: edges.get(u)) {
            if (visited[v] == 0) {
                dfs(v);
                if (!valid) {
                    return;
                }
            }

            else if (visited[v] == 1) {
                valid = false;
                return;
            }
        }       
        visited[u] = 2;
        result[index--] = u;
    }
}
```

```java
class Solution {

    List<List<Integer>> edges;    
    int[] indeg;    
    int[] result;
    int index;

    public int[] findOrder(int numCourses, int[][] prerequisites) {
        edges = new ArrayList<List<Integer>>();
        for (int i = 0; i < numCourses; ++i) {
            edges.add(new ArrayList<Integer>());
        }
        indeg = new int[numCourses];
        result = new int[numCourses];
        index = 0;
        for (int[] info : prerequisites) {
            edges.get(info[1]).add(info[0]);
            ++indeg[info[0]];
        }

        Queue<Integer> queue = new LinkedList<Integer>();
        // 将所有入度为 0 的节点放入队列中
        for (int i = 0; i < numCourses; ++i) {
            if (indeg[i] == 0) {
                queue.offer(i);
            }
        }

        while (!queue.isEmpty()) {
            // 从队首取出一个节点
            int u = queue.poll();
            // 放入答案中
            result[index++] = u;
            for (int v: edges.get(u)) {
                --indeg[v];
                // 如果相邻节点 v 的入度为 0，就可以选 v 对应的课程了
                if (indeg[v] == 0) {
                    queue.offer(v);
                }
            }
        }

        if (index != numCourses) {
            return new int[0];
        }
        return result;
    }
}
```

#### [329. 矩阵中的最长递增路径](https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix/)

给定一个 `m x n` 整数矩阵 `matrix` ，找出其中 **最长递增路径** 的长度。

对于每个单元格，你可以往上，下，左，右四个方向移动。 你 **不能** 在 **对角线** 方向上移动或移动到 **边界外**（即不允许环绕）。

**示例 1：**

![img](/img/grid1.jpg)

> 输入：matrix = [[9,9,4],[6,6,8],[2,1,1]]
> 输出：4 
> 解释：最长递增路径为 [1, 2, 6, 9]。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2021/01/27/tmp-grid.jpg)

> 输入：matrix = [[3,4,5],[3,2,6],[2,2,1]]
> 输出：4 
> 解释：最长递增路径是 [3, 4, 5, 6]。注意不允许在对角线方向上移动。

**示例 3：**

> 输入：matrix = [[1]]
> 输出：1

**提示：**

- `m == matrix.length`
- `n == matrix[i].length`
- `1 <= m, n <= 200`
- `0 <= matrix[i][j] <= 231 - 1`

如果从入度为0处开始依次连接每个结点，得到的就是一个有向无环图。

```java
class Solution {
    public int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int rows, columns;

    public int longestIncreasingPath(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        rows = matrix.length;
        columns = matrix[0].length;
        int[][] memory = new int[rows][columns];
        int ans = 0;
        for (int i = 0; i < rows; i++) {
            for (int j = 0; j < columns;j++) {
                int tmp = dfs(matrix, i, j, memory);
                ans = Math.max(ans, tmp);
            }
        }
        return ans;
    }

    public boolean isOutEdge(int newRow, int newColumn) {
        if (newRow < 0 || newRow >= rows || newColumn < 0 || newColumn >= columns) {
            return true;
        }
        return false;
    }
    public int dfs(int[][] matrix, int row, int column, int[][] memory) {
        if (memory[row][column] != 0) {
            return memory[row][column];
        }
        memory[row][column]++;
        for (int[] dir : dirs) {
            int newRow = row + dir[0], newColumn = column + dir[1];
            if (!isOutEdge(newRow, newColumn) && matrix[newRow][newColumn] > matrix[row][column]) {
                // 这里采用了动态规划的思想，假如单元格数字为9的最长递增路径为a，则数字为8的就应该是a+1;
                int tmp = dfs(matrix, newRow, newColumn, memory) + 1;
                memory[row][column] = Math.max(memory[row][column], tmp);
            }
        }
        return memory[row][column];
    }
}
```

**复杂度分析**

* 时间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数。
* 空间复杂度：O(mn)，其中 m和 n 分别是矩阵的行数和列数。

这道题除了可以采用记忆深度优先以外还可以采用拓扑排序的方式：

```java
class Solution {
    public int[][] dirs = {{-1, 0}, {1, 0}, {0, -1}, {0, 1}};
    public int rows, columns;

    public boolean isOutEdge(int newRow, int newColumn) {
        if (newRow < 0 || newRow >= rows || newColumn < 0 || newColumn >= columns) {
            return true;
        }
        return false;
    }

    public int longestIncreasingPath(int[][] matrix) {
        if (matrix == null || matrix.length == 0 || matrix[0].length == 0) {
            return 0;
        }
        rows = matrix.length;
        columns = matrix[0].length;
        int[][] outdegrees = new int[rows][columns];
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < columns; ++j) {
                for (int[] dir : dirs) {
                    int newRow = i + dir[0], newColumn = j + dir[1];
                    if (!isOutEdge(newRow, newColumn) && matrix[newRow][newColumn] > matrix[i][j]) {
                        ++outdegrees[i][j];
                    }
                }
            }
        }
        Queue<Pair> queue = new LinkedList<Pair>();
        for (int i = 0; i < rows; ++i) {
            for (int j = 0; j < columns; ++j) {
                if (outdegrees[i][j] == 0) {
                    queue.offer(new Pair(i, j));
                }
            }
        }
        int ans = 0;
        while (!queue.isEmpty()) {
            ++ans;
            int size = queue.size();
            for (int i = 0; i < size; ++i) {
                Pair pair = queue.poll();
                int row = pair.x, column = pair.y;
                for (int[] dir : dirs) {
                    int newRow = row + dir[0], newColumn = column + dir[1];
                    if (!isOutEdge(newRow, newColumn) && matrix[newRow][newColumn] < matrix[row][column]) {
                        --outdegrees[newRow][newColumn];
                        if (outdegrees[newRow][newColumn] == 0) {
                            queue.offer(new Pair(newRow, newColumn));
                        }
                    }
                }
            }
        }
        return ans;
    }
}

class Pair {
    int x;
    int y;
    public Pair(int x, int y) {
        this.x = x;
        this.y = y;
    }
}

```

**复杂度分析**

* 时间复杂度：O(mn)，其中 m 和 n 分别是矩阵的行数和列数。
* 空间复杂度：O(mn)，其中 m和 n 分别是矩阵的行数和列数。

#### [2603. 收集树中金币](https://leetcode.cn/problems/collect-coins-in-a-tree/)

给你一个 `n` 个节点的无向无根树，节点编号从 `0` 到 `n - 1` 。给你整数 `n` 和一个长度为 `n - 1` 的二维整数数组 `edges` ，其中 `edges[i] = [ai, bi]` 表示树中节点 `ai` 和 `bi` 之间有一条边。再给你一个长度为 `n` 的数组 `coins` ，其中 `coins[i]` 可能为 `0` 也可能为 `1` ，`1` 表示节点 `i` 处有一个金币。

一开始，你需要选择树中任意一个节点出发。你可以执行下述操作任意次：

- 收集距离当前节点距离为 `2` 以内的所有金币，或者
- 移动到树中一个相邻节点。

你需要收集树中所有的金币，并且回到出发节点，请你返回最少经过的边数。

如果你多次经过一条边，每一次经过都会给答案加一。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2023/03/01/graph-2.png)

> 输入：coins = [1,0,0,0,0,1], edges = [[0,1],[1,2],[2,3],[3,4],[4,5]]
> 输出：2
> 解释：从节点 2 出发，收集节点 0 处的金币，移动到节点 3 ，收集节点 5 处的金币，然后移动回节点 2 。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2023/03/02/graph-4.png)

> 输入：coins = [0,0,0,1,1,0,0,1], edges = [[0,1],[0,2],[1,3],[1,4],[2,5],[5,6],[5,7]]
> 输出：2
> 解释：从节点 0 出发，收集节点 4 和 3 处的金币，移动到节点 2 处，收集节点 7 处的金币，移动回节点 0 。

 

**提示：**

- `n == coins.length`
- `1 <= n <= 3 * 104`
- `0 <= coins[i] <= 1`
- `edges.length == n - 1`
- `edges[i].length == 2`
- `0 <= ai, bi < n`
- `ai != bi`
- `edges` 表示一棵合法的树。

```
class Solution {
    public int collectTheCoins(int[] coins, int[][] edges) {
        ArrayList<Integer>[] graph = new ArrayList[coins.length];
        for (int i = 0; i < graph.length; i++) {
            graph[i] = new ArrayList<>();
        }
        int[] deg = new int[coins.length];

        for (int i = 0; i < edges.length; i++) {
            graph[edges[i][0]].add(edges[i][1]);
            graph[edges[i][1]].add(edges[i][0]);
            deg[edges[i][0]]++;
            deg[edges[i][1]]++;
        }
        
        // 无向图拓扑排序, 去掉没有金币的子树
        Queue<Integer> que = new LinkedList<>();
        for (int i = 0; i < coins.length; i++) {
            if (deg[i] == 1 && coins[i] == 0) {
                que.add(i);
            }
        }
        while (!que.isEmpty()) {
            int u = que.poll();
            for (int i = 0; i < graph[u].size(); i++) {
                int v = graph[u].get(i);
                if (--deg[v] == 1 && coins[v] == 0) {
                    que.add(v);
                }
            }
        }

        for (int i = 0; i < coins.length; i++) {
            if (deg[i] == 1 && coins[i] == 1) {
                que.add(i);
            }
        }
        if (que.size() <= 1) {
            return 0;
        }
        int[] times = new int[coins.length];
        while (!que.isEmpty()) {
            int u = que.poll();
            for (int i = 0; i < graph[u].size(); i++) {
                int v = graph[u].get(i);
                if (--deg[v] == 1) {
                    times[v] = times[u] + 1;
                    que.add(v);
                }
            }
        }
        int ans = 0;
        for (int i = 0; i < edges.length; i++) {
            if (times[edges[i][0]] >= 2 && times[edges[i][1]] >= 2) {
                ans += 2;
            }
        }
        return ans;
    }
}
```





### 单调栈

#### [2617. 网格图中最少访问的格子数](https://leetcode.cn/problems/minimum-number-of-visited-cells-in-a-grid/)

给你一个下标从 **0** 开始的 `m x n` 整数矩阵 `grid` 。你一开始的位置在 **左上角** 格子 `(0, 0)` 。

当你在格子 `(i, j)` 的时候，你可以移动到以下格子之一：

- 满足 `j < k <= grid[i][j] + j` 的格子 `(i, k)` （向右移动），或者
- 满足 `i < k <= grid[i][j] + i` 的格子 `(k, j)` （向下移动）。

请你返回到达 **右下角** 格子 `(m - 1, n - 1)` 需要经过的最少移动格子数，如果无法到达右下角格子，请你返回 `-1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2023/01/25/ex1.png)

> 输入：grid = [[3,4,2,1],[4,2,3,1],[2,1,0,0],[2,4,0,0]]
> 输出：4
> 解释：上图展示了到达右下角格子经过的 4 个格子。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2023/01/25/ex2.png)

> 输入：grid = [[3,4,2,1],[4,2,1,1],[2,1,1,0],[3,4,1,0]]
> 输出：3
> 解释：上图展示了到达右下角格子经过的 3 个格子。

**示例 3：**

![img](https://assets.leetcode.com/uploads/2023/01/26/ex3.png)

> 输入：grid = [[2,1,0],[1,0,0]]
> 输出：-1
> 解释：无法到达右下角格子。

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `1 <= m, n <= 105`
- `1 <= m * n <= 105`
- `0 <= grid[i][j] < m * n`
- `grid[m - 1][n - 1] == 0`

```
class Solution {
    public int binSearch(ArrayList<Pair> rowStack, int target) {
        int l = 0;
        int r = rowStack.size() - 1;

        while (l <= r) {
            int mid = l + (r - l) / 2;
            if (rowStack.get(mid).idx > target) {
                l = mid + 1;
            } else {
                r = mid - 1;
            }
        }
        return l;
    }

    public int minimumVisitedCells(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        ArrayList<Pair>[] colStack = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            colStack[i] = new ArrayList<>();
        } 
        int minVal = 0;
        for (int i = m - 1; i >= 0; i--) {
            ArrayList<Pair> rowStack = new ArrayList<>();
            for (int j = n - 1; j >= 0; j--) {
                minVal = Integer.MAX_VALUE;
                if (i == m - 1 && j == n - 1) {
                    minVal = 0;
                } else if (grid[i][j] > 0) {
                    int k = binSearch(rowStack, j + grid[i][j]);
                    if (k < rowStack.size()) {
                        minVal = Math.min(minVal, rowStack.get(k).minVal);
                    }
                    k = binSearch(colStack[j], i + grid[i][j]);
                    if (k < colStack[j].size()) {
                        minVal = Math.min(minVal, colStack[j].get(k).minVal);
                    }
                }
                if (minVal == Integer.MAX_VALUE) {
                    continue;
                }
                minVal++; // 加上(i, j)这个格子

                while ((!rowStack.isEmpty()) &&
                       (minVal <= rowStack.get(rowStack.size() - 1).minVal)) {
                    rowStack.remove(rowStack.size() - 1);    
                }
                rowStack.add(new Pair(minVal, j));
                while ((!colStack[j].isEmpty()) &&
                       (minVal <= colStack[j].get(colStack[j].size() - 1).minVal)) {
                        colStack[j].remove(colStack[j].size() - 1);
                }
                colStack[j].add(new Pair(minVal, i));
            }
        }
        return minVal < Integer.MAX_VALUE ? minVal : -1;
    }
}

class Pair {
    int minVal;
    int idx;

    public Pair(int minVal, int idx) {
        this.minVal = minVal;
        this.idx = idx;
    }
}
```

### 环

#### [2608. 图中的最短环](https://leetcode.cn/problems/shortest-cycle-in-a-graph/)

现有一个含 `n` 个顶点的 **双向** 图，每个顶点按从 `0` 到 `n - 1` 标记。图中的边由二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和 `vi` 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。

返回图中 **最短** 环的长度。如果不存在环，则返回 `-1` 。

**环** 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2023/01/04/cropped.png)

> 输入：n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]
> 输出：3
> 解释：长度最小的循环是：0 -> 1 -> 2 -> 0 

**示例 2：**

![img](https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png)

> 输入：n = 4, edges = [[0,1],[0,2]]
> 输出：-1
> 解释：图中不存在循环

 

**提示：**

- `2 <= n <= 1000`
- `1 <= edges.length <= 1000`
- `edges[i].length == 2`
- `0 <= ui, vi < n`
- `ui != vi`
- 不存在重复的边

```
class Solution {
    public int dijkstra(ArrayList<Integer>[] graph, int start, int end, int n) {
        int[] distance = new int[n];
        for (int i = 0; i < n; i++) {
            distance[i] = Integer.MAX_VALUE;
        }

        distance[start] = 0;
        PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> (a.distance - b.distance));
        pq.add(new Node(start, 0));
        while (!pq.isEmpty()) {
            Node cur = pq.poll();
            if (distance[cur.x] != cur.distance) {
                continue;
            }
            ArrayList<Integer> list = graph[cur.x];
            for (int i = 0; i < list.size(); i++) {
                int val = list.get(i);
                if ((cur.x == start && val == end)||
                    (cur.x == end && val == start)) {
                    continue;
                }

                if (distance[cur.x] + 1 < distance[val]) {
                    distance[val] = distance[cur.x] + 1;
                    pq.add(new Node(val, distance[cur.x] + 1));
                }
            }
        }
        return distance[end] == Integer.MAX_VALUE ? -1 : distance[end];
    }

    public int findShortestCycle(int n, int[][] edges) {
        ArrayList<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        int min = Integer.MAX_VALUE;
        for (int[] edge : edges) {
            int distance = dijkstra(graph, edge[0], edge[1], n);
            if (distance != -1 && distance < min) {
                min = distance;
            }
        }
        return min == Integer.MAX_VALUE ? -1 : min + 1;
    }
}

class Node {
    int x;
    int distance;

    public Node(int x, int distance) {
        this.x = x;
        this.distance = distance;
    }
}
```



### 最短路问题

#### [2608. 图中的最短环](https://leetcode.cn/problems/shortest-cycle-in-a-graph/)

现有一个含 `n` 个顶点的 **双向** 图，每个顶点按从 `0` 到 `n - 1` 标记。图中的边由二维整数数组 `edges` 表示，其中 `edges[i] = [ui, vi]` 表示顶点 `ui` 和 `vi` 之间存在一条边。每对顶点最多通过一条边连接，并且不存在与自身相连的顶点。

返回图中 **最短** 环的长度。如果不存在环，则返回 `-1` 。

**环** 是指以同一节点开始和结束，并且路径中的每条边仅使用一次。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2023/01/04/cropped.png)

> 输入：n = 7, edges = [[0,1],[1,2],[2,0],[3,4],[4,5],[5,6],[6,3]]
> 输出：3
> 解释：长度最小的循环是：0 -> 1 -> 2 -> 0 

**示例 2：**

![img](https://assets.leetcode.com/uploads/2023/01/04/croppedagin.png)

> 输入：n = 4, edges = [[0,1],[0,2]]
> 输出：-1
> 解释：图中不存在循环

 

**提示：**

- `2 <= n <= 1000`
- `1 <= edges.length <= 1000`
- `edges[i].length == 2`
- `0 <= ui, vi < n`
- `ui != vi`
- 不存在重复的边

```
class Solution {
    public int dijkstra(ArrayList<Integer>[] graph, int start, int end, int n) {
        int[] distance = new int[n];
        for (int i = 0; i < n; i++) {
            distance[i] = Integer.MAX_VALUE;
        }

        distance[start] = 0;
        PriorityQueue<Node> pq = new PriorityQueue<>((a, b) -> (a.distance - b.distance));
        pq.add(new Node(start, 0));
        while (!pq.isEmpty()) {
            Node cur = pq.poll();
            if (distance[cur.x] != cur.distance) {
                continue;
            }
            ArrayList<Integer> list = graph[cur.x];
            for (int i = 0; i < list.size(); i++) {
                int val = list.get(i);
                if ((cur.x == start && val == end)||
                    (cur.x == end && val == start)) {
                    continue;
                }

                if (distance[cur.x] + 1 < distance[val]) {
                    distance[val] = distance[cur.x] + 1;
                    pq.add(new Node(val, distance[cur.x] + 1));
                }
            }
        }
        return distance[end] == Integer.MAX_VALUE ? -1 : distance[end];
    }

    public int findShortestCycle(int n, int[][] edges) {
        ArrayList<Integer>[] graph = new ArrayList[n];
        for (int i = 0; i < n; i++) {
            graph[i] = new ArrayList<>();
        }
        for (int[] edge : edges) {
            graph[edge[0]].add(edge[1]);
            graph[edge[1]].add(edge[0]);
        }
        int min = Integer.MAX_VALUE;
        for (int[] edge : edges) {
            int distance = dijkstra(graph, edge[0], edge[1], n);
            if (distance != -1 && distance < min) {
                min = distance;
            }
        }
        return min == Integer.MAX_VALUE ? -1 : min + 1;
    }
}

class Node {
    int x;
    int distance;

    public Node(int x, int distance) {
        this.x = x;
        this.distance = distance;
    }
}
```

#### [2577. 在网格图中访问一个格子的最少时间](https://leetcode.cn/problems/minimum-time-to-visit-a-cell-in-a-grid/)

给你一个 `m x n` 的矩阵 `grid` ，每个元素都为 **非负** 整数，其中 `grid[row][col]` 表示可以访问格子 `(row, col)` 的 **最早** 时间。也就是说当你访问格子 `(row, col)` 时，最少已经经过的时间为 `grid[row][col]` 。

你从 **最左上角** 出发，出发时刻为 `0` ，你必须一直移动到上下左右相邻四个格子中的 **任意** 一个格子（即不能停留在格子上）。每次移动都需要花费 1 单位时间。

请你返回 **最早** 到达右下角格子的时间，如果你无法到达右下角的格子，请你返回 `-1` 。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-8.png)

> 输入：grid = [[0,1,3,2],[5,1,2,5],[4,3,8,6]]
> 输出：7
> 解释：一条可行的路径为：
>
> - 时刻 t = 0 ，我们在格子 (0,0) 。
> - 时刻 t = 1 ，我们移动到格子 (0,1) ，可以移动的原因是 grid[0][1] <= 1 。
> - 时刻 t = 2 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] <= 2 。
> - 时刻 t = 3 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] <= 3 。
> - 时刻 t = 4 ，我们移动到格子 (1,1) ，可以移动的原因是 grid[1][1] <= 4 。
> - 时刻 t = 5 ，我们移动到格子 (1,2) ，可以移动的原因是 grid[1][2] <= 5 。
> - 时刻 t = 6 ，我们移动到格子 (1,3) ，可以移动的原因是 grid[1][3] <= 6 。
> - 时刻 t = 7 ，我们移动到格子 (2,3) ，可以移动的原因是 grid[2][3] <= 7 。
>   最终到达时刻为 7 。这是最早可以到达的时间。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2023/02/14/yetgriddrawio-9.png)

> 输入：grid = [[0,2,4],[3,2,1],[1,0,4]]
> 输出：-1
> 解释：没法从左上角按题目规定走到右下角。

 

**提示：**

- `m == grid.length`
- `n == grid[i].length`
- `2 <= m, n <= 1000`
- `4 <= m * n <= 105`
- `0 <= grid[i][j] <= 105`
- `grid[0][0] == 0`

```
class Solution {
    public int minimumTime(int[][] grid) {
        int m = grid.length;
        int n = grid[0].length;

        if (grid[0][1] > 1 && grid[1][0] > 1) {
            return -1;
        }
        PriorityQueue<Node> que = new PriorityQueue<>((node1, node2) -> (node1.distance - node2.distance));

        int[][] dis = new int[m][n];
        for (int i = 0; i < m; i++) {
            for (int j = 0; j < n; j++) {
                dis[i][j] = Integer.MAX_VALUE;
            }
        }

        que.add(new Node(0, 0, 0));
        dis[0][0] = 0;

        int[] movX = new int[]{0, -1, 0, 1};
        int[] movY = new int[]{1, 0, -1, 0};
        while (!que.isEmpty()) {
            Node node = que.poll();
            if (dis[node.x][node.y] != node.distance) {
                continue;
            }
            for (int i = 0; i < 4; i++) {
                int newX = node.x + movX[i];
                int newY = node.y + movY[i];
                if (newX < 0 || newX >= m || newY < 0 || newY >= n) {
                    continue;
                }
                int newDistance = node.distance + 1;
                int waitTime = Math.max(0, grid[newX][newY] - newDistance);
                waitTime += waitTime % 2 == 0 ? 0 : 1;
                newDistance += waitTime;
                if (newDistance < dis[newX][newY]) {
                    dis[newX][newY] = newDistance;
                    que.add(new Node(newX, newY, newDistance));
                }
            }
        }
        int ans = dis[m - 1][n - 1];
        return ans == Integer.MAX_VALUE ? -1 : ans;
    }
}

class Node {
    int x;
    int y;
    int distance;

    public Node(int x, int y, int distance) {
        this.x = x;
        this.y = y;
        this.distance = distance;
    }
}
```

### 树换根

#### [2581. 统计可能的树根数目](https://leetcode.cn/problems/count-number-of-possible-root-nodes/)

Alice 有一棵 `n` 个节点的树，节点编号为 `0` 到 `n - 1` 。树用一个长度为 `n - 1` 的二维整数数组 `edges` 表示，其中 `edges[i] = [ai, bi]` ，表示树中节点 `ai` 和 `bi` 之间有一条边。

Alice 想要 Bob 找到这棵树的根。她允许 Bob 对这棵树进行若干次 **猜测** 。每一次猜测，Bob 做如下事情：

- 选择两个 **不相等** 的整数 `u` 和 `v` ，且树中必须存在边 `[u, v]` 。
- Bob 猜测树中 `u` 是 `v` 的 **父节点** 。

Bob 的猜测用二维整数数组 `guesses` 表示，其中 `guesses[j] = [uj, vj]` 表示 Bob 猜 `uj` 是 `vj` 的父节点。

Alice 非常懒，她不想逐个回答 Bob 的猜测，只告诉 Bob 这些猜测里面 **至少** 有 `k` 个猜测的结果为 `true` 。

给你二维整数数组 `edges` ，Bob 的所有猜测和整数 `k` ，请你返回可能成为树根的 **节点数目** 。如果没有这样的树，则返回 `0`。

 

**示例 1：**

![img](https://assets.leetcode.com/uploads/2022/12/19/ex-1.png)

> 输入：edges = [[0,1],[1,2],[1,3],[4,2]], guesses = [[1,3],[0,1],[1,0],[2,4]], k = 3
> 输出：3
> 解释：
> 根为节点 0 ，正确的猜测为 [1,3], [0,1], [2,4]
> 根为节点 1 ，正确的猜测为 [1,3], [1,0], [2,4]
> 根为节点 2 ，正确的猜测为 [1,3], [1,0], [2,4]
> 根为节点 3 ，正确的猜测为 [1,0], [2,4]
> 根为节点 4 ，正确的猜测为 [1,3], [1,0]
> 节点 0 ，1 或 2 为根时，可以得到 3 个正确的猜测。

**示例 2：**

![img](https://assets.leetcode.com/uploads/2022/12/19/ex-2.png)

> 输入：edges = [[0,1],[1,2],[2,3],[3,4]], guesses = [[1,0],[3,4],[2,1],[3,2]], k = 1
> 输出：5
> 解释：
> 根为节点 0 ，正确的猜测为 [3,4]
> 根为节点 1 ，正确的猜测为 [1,0], [3,4]
> 根为节点 2 ，正确的猜测为 [1,0], [2,1], [3,4]
> 根为节点 3 ，正确的猜测为 [1,0], [2,1], [3,2], [3,4]
> 根为节点 4 ，正确的猜测为 [1,0], [2,1], [3,2]
> 任何节点为根，都至少有 1 个正确的猜测。

 

**提示：**

- `edges.length == n - 1`
- `2 <= n <= 105`
- `1 <= guesses.length <= 105`
- `0 <= ai, bi, uj, vj <= n - 1`
- `ai != bi`
- `uj != vj`
- `edges` 表示一棵有效的树。
- `guesses[j]` 是树中的一条边。
- `guesses` 是唯一的。
- `0 <= k <= guesses.length`

```
class Solution {
    ArrayList<Integer>[] edge;
    HashMap<Node, Integer> map;  // 统计Bob对Node中a是b的父亲猜了多少次
    int cur, ans, K;

    public void dfs(Node node) {
        cur += map.getOrDefault(node, 0);
        for (int i = 0; i < edge[node.b].size(); i++) {
            if (edge[node.b].get(i) != node.a) { // 因为是无向图，需要避免来回横跳
                dfs(new Node(node.b, edge[node.b].get(i)));
            }
        }
    }

    public void reRoot(Node node) {
        if (cur >= K) {
            ans += 1;
        }
        for (int i = 0; i < edge[node.b].size(); i++) {  // 换根，从node.b 换到 edge[node.b].get(i)
            if (edge[node.b].get(i) != node.a) {
                int back = cur;
                cur -= map.getOrDefault(new Node(node.b, edge[node.b].get(i)), 0);
                cur += map.getOrDefault(new Node(edge[node.b].get(i), node.b), 0);
                reRoot(new Node(node.b, edge[node.b].get(i)));
                cur = back;
            }
        }
    }

    public int rootCount(int[][] edges, int[][] guesses, int k) {
        int n = edges.length;
        int m = guesses.length;
        K = k;
        cur = 0;
        ans = 0;
        edge = new ArrayList[n + 1];
        map = new HashMap<>();

        for (int i = 0; i < edge.length; i++) {
            edge[i] = new ArrayList<>();
        }
        for (int i = 0; i < n; i++) {
            edge[edges[i][0]].add(edges[i][1]);
            edge[edges[i][1]].add(edges[i][0]);
        }
        for (int i = 0; i < m; i++) {
            Node node = new Node(guesses[i][0], guesses[i][1]);
            int cnt = map.getOrDefault(node, 0);
            map.put(node, cnt + 1);
        }
        dfs(new Node(-1, 0)); // 统计 0 作为根节点Bob猜对的次数

        reRoot(new Node(-1, 0));
        return ans;
    }
}

class Node {
    int a; // 表示从a到b
    int b;
    public Node(int a, int b) {
        this.a = a;
        this.b = b;
    }

    @Override
    public boolean equals(Object obj) {
        Node node = (Node) obj;
        if (this.a == node.a && this.b == node.b) {
            return true;
        }
        return false;
    }

    @Override
    public int hashCode() {
        return (a << 16) | b;
    }
}
```

### 完全图

#### [2685. 统计完全连通分量的数量](https://leetcode.cn/problems/count-the-number-of-complete-components/)

给你一个整数 `n` 。现有一个包含 `n` 个顶点的 **无向** 图，顶点按从 `0` 到 `n - 1` 编号。给你一个二维整数数组 `edges` 其中 `edges[i] = [ai, bi]` 表示顶点 `ai` 和 `bi` 之间存在一条 **无向** 边。

返回图中 **完全连通分量** 的数量。

如果在子图中任意两个顶点之间都存在路径，并且子图中没有任何一个顶点与子图外部的顶点共享边，则称其为 **连通分量** 。

如果连通分量中每对节点之间都存在一条边，则称其为 **完全连通分量** 。

 

**示例 1：**

**![img](https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-31-23.png)**

> 输入：n = 6, edges = [[0,1],[0,2],[1,2],[3,4]]
> 输出：3
> 解释：如上图所示，可以看到此图所有分量都是完全连通分量。

**示例 2：**

**![img](https://assets.leetcode.com/uploads/2023/04/11/screenshot-from-2023-04-11-23-32-00.png)**

> 输入：n = 6, edges = [[0,1],[0,2],[1,2],[3,4],[3,5]]
> 输出：1
> 解释：包含节点 0、1 和 2 的分量是完全连通分量，因为每对节点之间都存在一条边。
> 包含节点 3 、4 和 5 的分量不是完全连通分量，因为节点 4 和 5 之间不存在边。
> 因此，在图中完全连接分量的数量是 1 。

 

**提示：**

- `1 <= n <= 50`
- `0 <= edges.length <= n * (n - 1) / 2`
- `edges[i].length == 2`
- `0 <= ai, bi <= n - 1`
- `ai != bi`
- 不存在重复的边

```
/*
    完全图有n 个顶点 m 条边，则 m = (n - 1) * n / 2
*/

class Solution {
    ArrayList<ArrayList<Integer>> graph;
    int verticesCnt, edgeCnt;
    public void dfs(int n, int x, boolean[] isVisited) {
        if (x >= n || isVisited[x]) {
            return;
        }
        
        isVisited[x] = true;
        verticesCnt++;
        edgeCnt += graph.get(x).size();
        for (int y : graph.get(x)) {
            dfs(n, y, isVisited);
        }
    }
    
    public int countCompleteComponents(int n, int[][] edges) {
        if (n == 1) {
            return 1;
        }
        
        int ans = 0;
        boolean[] isVisited = new boolean[n];
        graph = new ArrayList<>();
        
        for (int i = 0; i < n; i++) {
            graph.add(new ArrayList<>());
        }
        
        for (int[] edge : edges) {
            graph.get(edge[0]).add(edge[1]);
            graph.get(edge[1]).add(edge[0]);
        }
        
        for (int i = 0; i < n; i++) {
            if (isVisited[i]) {
                continue;
            }
            edgeCnt = 0;
            verticesCnt = 0;
            dfs(n, i, isVisited);
            if (edgeCnt == verticesCnt * (verticesCnt - 1)) {
                ans++;
            }
        }
        return ans;
    }
}
```

