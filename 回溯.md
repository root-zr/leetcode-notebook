### 回溯

回溯法求解问题的第一步就是确定解空间，该解空间至少包含一个最优解。

基本思想是形成一个解空间树，对解空间树进行深度优先遍历，对解空间中所有可能的取值进行扫描，进而找到最优解。

提高效率的措施：

  （1）根据约束条件，对不满足要求的部分解，终止之后的子树的搜索；

  （2）根据已经求得的当前最好的解，对后续的解进行剪枝。

先以[剑指 Offer 38. 字符串的排列](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/)为例：

输入一个字符串，打印出该字符串中字符的所有排列。

 你可以以任意顺序返回这个字符串数组，但里面不能有重复元素。

 **示例:**

> 输入：s = "abc"
> 输出：["abc","acb","bac","bca","cab","cba"]

**限制：**

1 <= s 的长度 <= 8

先不考虑重复值的情况，解空间树就如下

![image-20210918164850606](img/image-20210918164850606.png)

图片及代码均来自[剑指 Offer 38. 字符串的排列（回溯法，清晰图解） - 字符串的排列 - 力扣（LeetCode） (leetcode-cn.com)](https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof/solution/mian-shi-ti-38-zi-fu-chuan-de-pai-lie-hui-su-fa-by/)

这样在第一层循环中，第一个字符可以和后面的n-1个字符进行交换，可能的情况就是n种，当第一个字符确定下来以后，后面所有的情况就会每次减少一个，直到最后只有一种情况。

这题需要考虑到有重复值的情况，在有重复值的情况下，加入第i位的字符是a，第j位的字符也是a.那我们交换这两个字符实际上是一种情况，如果不考虑就会使最后的结果偏大。所以我们必须得在确保开始交换之前保证要交换的两个字符是不一样的。

为了节省空间，我们直接在原数组的基础上交换，最后把数组中形成的结果拷贝记录下来。另外这里需要注意到我们在交换之后数组会发生改变，所以我们要执行一个相反的操作把数组还原回来。

最后要注意的是我们的第一次交换是自己和自己交换，也就是第一次是不交换（原始）的情况。

```java
class Solution {
    List<String> res = new LinkedList<>();
    char[] c;
    public String[] permutation(String s) {
        c = s.toCharArray();
        dfs(0);
        return res.toArray(new String[res.size()]);
    }
    void dfs(int x) {
        if(x == c.length - 1) {
            res.add(String.valueOf(c));      // 添加排列方案
            return;
        }
        HashSet<Character> set = new HashSet<>();
        for(int i = x; i < c.length; i++) {
            if(set.contains(c[i])) continue; // 重复，因此剪枝
            set.add(c[i]);
            swap(i, x);                      // 交换，将 c[i] 固定在第 x 位
            dfs(x + 1);                      // 开启固定第 x + 1 位字符
            swap(i, x);                      // 恢复交换
        }
    }
    void swap(int a, int b) {
        char tmp = c[a];
        c[a] = c[b];
        c[b] = tmp;
    }
}
```

同类型的题还有很多，比如：

#### [46. 全排列](https://leetcode-cn.com/problems/permutations/)

给定一个不含重复数字的数组 `nums` ，返回其 **所有可能的全排列** 。你可以 **按任意顺序** 返回答案。

**示例 1：**

> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

**示例 2：**

> 输入：nums = [0,1]
> 输出：[[0,1],[1,0]]

**示例 3：**

> 输入：nums = [1]
> 输出：[[1]]

**提示：**

- `1 <= nums.length <= 6`
- `-10 <= nums[i] <= 10`
- `nums` 中的所有整数 **互不相同**

```Java
class Solution {
    int[] nums;
    List<List<Integer>> res ;
    public List<List<Integer>> permute(int[] nums) {
        res = new ArrayList<>();     
        this.nums = nums;
        dfs(0);

        return res;
    }

    public void dfs(int num){
        if(num == nums.length - 1){
            List<Integer> arr = new ArrayList<>();
            for(int i = 0 ; i < nums.length ; i ++){
                arr.add(nums[i]);
            }
            
            res.add(arr);
            return;
        }
       
        for(int i = num; i < nums.length; i++){
            swap(num,i);
            dfs(num + 1); //这里必须要用num + 1而不是++num，否则在下面的swap中下标就会不一致
            swap(num,i);
        }

    }

    public void swap(int a, int b){
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;

    }
}
```

#### [47. 全排列 II](https://leetcode-cn.com/problems/permutations-ii/)

给定一个可包含重复数字的序列 `nums` ，**按任意顺序** 返回所有不重复的全排列。

**示例 1：**

> 输入：nums = [1,1,2]
> 输出：
> [[1,1,2],
>  [1,2,1],
>  [2,1,1]]

**示例 2：**

> 输入：nums = [1,2,3]
> 输出：[[1,2,3],[1,3,2],[2,1,3],[2,3,1],[3,1,2],[3,2,1]]

**提示：**

- `1 <= nums.length <= 8`
- `-10 <= nums[i] <= 10`

```java
class Solution {
    int[] nums;
    List<List<Integer>> res ;
    public List<List<Integer>> permuteUnique(int[] nums) {
        res = new ArrayList<>();     
        this.nums = nums;
        dfs(0);
        return res;
    }

    public void dfs(int num){
        if(num == nums.length - 1){
            List<Integer> arr = new ArrayList<>();
            for(int i = 0 ; i < nums.length ; i ++){
                arr.add(nums[i]);
            }
            
            res.add(arr);
            return;
        }
        HashSet<Integer> set = new HashSet<>();

        for(int i = num; i < nums.length; i++){
            if(set.contains(nums[i])) continue; // 重复，因此剪枝
            set.add(nums[i]);
            swap(num,i);
            dfs(num + 1); //这里必须要用num + 1而不是++num，否则在下面的swap中下标就会不一致
            swap(num,i);
        }

    }

    public void swap(int a, int b){
        int tmp = nums[a];
        nums[a] = nums[b];
        nums[b] = tmp;

    }
}
```

#### [剑指 Offer II 086. 分割回文子字符串](https://leetcode-cn.com/problems/M99OJA/)

给定一个字符串 `s` ，请将 `s` 分割成一些子串，使每个子串都是 **回文串** ，返回 s 所有可能的分割方案。

**回文串** 是正着读和反着读都一样的字符串。

 **示例 1：**

> 输入：s = "google"
> 输出：[["g","o","o","g","l","e"],["g","oo","g","l","e"],["goog","l","e"]]

**示例 2：**

> 输入：s = "aab"
> 输出：[["a","a","b"],["aa","b"]]

**示例 3：**

> 输入：s = "a"
> 输出：[["a"] 

**提示：**

- `1 <= s.length <= 16`
- `s `仅由小写英文字母组成

```java
class Solution {
    public String[][] partition(String s) {
        // 排列组合问题，优先考虑用回溯的思路，然后加双指针回文串判断的模板
        List<String> tempPartition = new ArrayList<>();
        List<List<String>> partitions = new ArrayList<>();
        backTracking(s, tempPartition, partitions);
        
        //以下都是将List变成String类型然后返回
        String[][] res = new String[partitions.size()][];
        int outIdx = 0;
        for(List<String> tempRes : partitions) {
            String[] one = new String[tempRes.size()];
            int innerIdx = 0;
            for(String str : tempRes) {
                one[innerIdx++] = str;
            }
            res[outIdx++] = one;
        }
        return res;
    }

    private void backTracking(String s, List<String> tempPartition, List<List<String>> partitions) {
        if(s.length() == 0) {
            partitions.add(new ArrayList<>(tempPartition));
            return;
        }

        for(int i = 0; i < s.length(); ++i) {
            if(isPalindrome(s, 0, i)) {
                tempPartition.add(s.substring(0, i + 1));
                backTracking(s.substring(i + 1), tempPartition, partitions);
                tempPartition.remove(tempPartition.size() - 1);
            }
        }
    }

    // 回文串的标准判断模板
    private boolean isPalindrome(String s, int start, int end) {
         while(start < end) {
             if(s.charAt(start++) != s.charAt(end--)) {
                 return false;
             }
         }
         return true;
    }
}
```

#### [剑指 Offer 12. 矩阵中的路径](https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof/)

请设计一个函数，用来判断在一个矩阵中是否存在一条包含某字符串所有字符的路径。路径可以从矩阵中的任意一格开始，每一步可以在矩阵中向左、右、上、下移动一格。如果一条路径经过了矩阵的某一格，那么该路径不能再次进入该格子。例如，在下面的3×4的矩阵中包含一条字符串“bfce”的路径（路径中的字母用加粗标出）。

[["a","**b**","c","e"],
["s","**f**","**c**","s"],
["a","d","**e**","e"]]

但矩阵中不包含字符串“abfb”的路径，因为字符串的第一个字符b占据了矩阵中的第一行第二个格子之后，路径不能再次进入这个格子。

**示例 1：**

> 输入：board = [["A","B","C","E"],["S","F","C","S"],["A","D","E","E"]], word = "ABCCED"
> 输出：true

**示例 2：**

> 输入：board = [["a","b"],["c","d"]], word = "abcd"
> 输出：false

**提示：**

* 1 <= board.length <= 200
* 1 <= board[i].length <= 200

这题不同于分割回文字符串是在于回文字符串都是先从0开始分区间[0-i]，然后是[i+1,n]，所以这里是单重循环

```java
for(int i = 0; i < s.length(); ++i) {
            if(isPalindrome(s, 0, i)) {
                tempPartition.add(s.substring(0, i + 1));
                backTracking(s.substring(i + 1), tempPartition, partitions);
                tempPartition.remove(tempPartition.size() - 1);
            }
        }
```

但是这道题可以直接从i开始，所以要把上一道题的单重循环变成双重循环，从下标i开始。

```java
for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, words, i, j, 0)) return true;
            }
        }
```

具体代码如下：

```java
class Solution {
    public boolean exist(char[][] board, String word) {
        char[] words = word.toCharArray();
        for(int i = 0; i < board.length; i++) {
            for(int j = 0; j < board[0].length; j++) {
                if(dfs(board, words, i, j, 0)) return true;
            }
        }
        return false;
    }
    boolean dfs(char[][] board, char[] word, int i, int j, int k) {
        if(i >= board.length || i < 0 || j >= board[0].length || j < 0 || board[i][j] != word[k]) return false;
        if(k == word.length - 1) return true;
        board[i][j] = '\0';
        boolean res = dfs(board, word, i + 1, j, k + 1) || dfs(board, word, i - 1, j, k + 1) || 
                      dfs(board, word, i, j + 1, k + 1) || dfs(board, word, i , j - 1, k + 1);
        board[i][j] = word[k];
        return res;
    }
}
```

#### [剑指 Offer 13. 机器人的运动范围](https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof/)

地上有一个m行n列的方格，从坐标 [0,0] 到坐标 [m-1,n-1] 。一个机器人从坐标 [0, 0] 的格子开始移动，它每次可以向左、右、上、下移动一格（不能移动到方格外），也不能进入行坐标和列坐标的数位之和大于k的格子。例如，当k为18时，机器人能够进入方格 [35, 37] ，因为3+5+3+7=18。但它不能进入方格 [35, 38]，因为3+5+3+8=19。请问该机器人能够到达多少个格子？

**示例 1：**

> 输入：m = 2, n = 3, k = 1
> 输出：3

**示例 2：**

> 输入：m = 3, n = 1, k = 0
> 输出：1

**提示：**

*  1 <= n,m <= 100
*  0 <= k <= 20

```java
class Solution {
    int m,n,k;
    boolean[][] visited;
    public int movingCount(int m, int n, int k) {
        this.m = m; this.n = n; this.k = k;

        visited = new boolean[m][n]; //这里的visited和上题的“\0"一样都是为了防止多次计数
        return dfs(0,0);
    }

    public int dfs(int i, int j){
        if(i < 0 || i >= m || j < 0 || j >= n || visited[i][j] ||  getNum(i) +  getNum(j) > k)
            return 0;
        visited[i][j] = true;
        return dfs(i+1,j) + 1 + dfs(i ,j+1) +dfs(i-1,j) + dfs(i,j-1);
     //如果题目是问最大深度，这里就是MAX(dfs(i+1,j),dfs(i ,j+1) ,dfs(i-1,j) +,dfs(i,j-1)) + 1
    }

    public int getNum(int num){
        int res = 0 ;
        while(num != 0){
            res += num%10;
            num /= 10;
        }

        return res;
    }
}
```

