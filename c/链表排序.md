#### [剑指 Offer II 077. 链表排序](https://leetcode-cn.com/problems/7WHec2/)

给定链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。

**示例 1：**

![](img/sort_list_1.jpg)

> 输入：head = [4,2,1,3]
> 输出：[1,2,3,4]

**示例 2：**

![](img/sort_list_2.jpg)

> 输入：head = [-1,5,3,4,0]
> 输出：[-1,0,3,4,5]

**示例 3：**

> 输入：head = []
> 输出：[]

**提示：**

* 链表中节点的数目在范围 [0, 5 * 104] 内
* -10^5^ <= Node.val <= 10^5^

堆排序

```c
#define MAX_LINKED_SIZE 50001 

void Swap(struct ListNode *arr[], int a, int b)
{
    struct ListNode *tmp = arr[a];
    arr[a] = arr[b];
    arr[b] = tmp;
}

void Heapify(struct ListNode *arr[], int arrSize, int curIndex)
{
    int largestIndex = curIndex;
    int lChild = 2 * curIndex + 1;
    int rChild = 2 * curIndex + 2;

    if (lChild < arrSize && arr[lChild]->val > arr[largestIndex]->val) {
        largestIndex = lChild;
    }
 
    if (rChild < arrSize && arr[rChild]->val > arr[largestIndex]->val) {
        largestIndex = rChild;
    }
    if (largestIndex != curIndex) {
        Swap(arr, largestIndex, curIndex);
        Heapify(arr, arrSize, largestIndex);
    }

}

void HeapSort(struct ListNode *arr[], int arrSize)
{
    /*
    从第一个非叶子结点开始，自下而上建堆，因为叶子节点肯定是满足条件的，不需要再操作。
    当子结点的下标为i, 父结点 = (i - 1) / 2, 所以第一个非叶子结点为(arrSize - 1 - 1) / 2;
    */
    for(int i = arrSize / 2 - 1; i >= 0; i--) {
        Heapify(arr,arrSize,i);
    }
 
    //排序
    for (int i = arrSize -1; i >= 0; i--) {
        Swap(arr, i, 0);
        Heapify(arr, i, 0);
    }
}

struct ListNode *sortList(struct ListNode *head)
{
    if (head == NULL) {
        return head;
    }
    struct ListNode **arr = (struct ListNode **)malloc(MAX_LINKED_SIZE * sizeof(struct ListNode *));
    if (arr == NULL) {
        return NULL;
    }
    memset(arr, 0, MAX_LINKED_SIZE * sizeof(struct ListNode *));
    int size = 0;
    while (head != NULL) {
        arr[size] = head;
        size++;
        head = head->next;
    }

    HeapSort(arr, size);

    struct ListNode *tmp = arr[0];   
    for (int i = 1; i < size; i++) {
        tmp->next = arr[i];
        tmp = tmp->next;
    }
    tmp->next = NULL;

    return arr[0];
    
}
```

归并排序：

```c
struct ListNode * Merge(struct ListNode *head1, struct ListNode *head2)
{
    struct ListNode *dummy = (struct ListNode *)malloc(sizeof(struct ListNode));
    if (dummy == NULL) {
        return NULL;
    }
    memset(dummy, 0, sizeof(dummy));

    struct ListNode *cur = dummy;

    while (head1 != NULL && head2 != NULL) {
        if (head1->val < head2->val) {
            cur->next = head1;
            head1 = head1->next;
        } else {
            cur->next = head2;
            head2 = head2->next;
        }
        cur = cur->next;
    }

    if (head1 == NULL) {
        cur->next = head2;
    } else {
        cur->next = head1;
    }

    return dummy->next;
}

struct ListNode * MergeSort(struct ListNode *head)
{
    if (head == NULL || head->next == NULL) {
        return head;
    }
 
    struct ListNode *slow = head;
    struct ListNode *fast = head->next; // 这里不能为head，当只有两个元素的时候会陷入死循环
    while (fast != NULL && fast->next != NULL) {
        fast = fast->next->next;
        slow = slow->next;
    }

    struct ListNode *mid = slow->next;
    slow->next = NULL;
    struct ListNode *head1 = MergeSort(head);
    struct ListNode *head2 = MergeSort(mid);
    return Merge(head1,head2);
}
struct ListNode *sortList(struct ListNode *head)
{
   return MergeSort(head);   
}
```

