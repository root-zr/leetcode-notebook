### 递推

#### [剑指 Offer 10- II. 青蛙跳台阶问题](https://leetcode.cn/problems/qing-wa-tiao-tai-jie-wen-ti-lcof/)

一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 n 级的台阶总共有多少种跳法。

答案需要取模 1e9+7（1000000007），如计算初始结果为：1000000008，请返回 1。

示例 1：

> 输入：n = 2
> 输出：2

示例 2：

> 输入：n = 7
> 输出：21

示例 3：

> 输入：n = 0
> 输出：1

提示：

* 0 <= n <= 100

```c
#define MAX_INT 1000000007
int numWays(int n){
    if (n <= 1) {
        return 1;
    }

    int dp[n + 1];
    dp[0] = 1;
    dp[1] = 1;
    for (int i = 2; i <= n; i++) {
        dp[i] = (dp[i - 1] + dp[i - 2]) % MAX_INT;
    }
    return dp[n];
}
```

#### [1342. 将数字变成 0 的操作次数](https://leetcode.cn/problems/number-of-steps-to-reduce-a-number-to-zero/)

给你一个非负整数 num ，请你返回将它变成 0 所需要的步数。 如果当前数字是偶数，你需要把它除以 2 ；否则，减去 1 。

 示例 1：

> 输入：num = 14
> 输出：6
> 解释：
> 步骤 1) 14 是偶数，除以 2 得到 7 。
> 步骤 2） 7 是奇数，减 1 得到 6 。
> 步骤 3） 6 是偶数，除以 2 得到 3 。
> 步骤 4） 3 是奇数，减 1 得到 2 。
> 步骤 5） 2 是偶数，除以 2 得到 1 。
> 步骤 6） 1 是奇数，减 1 得到 0 。

示例 2：

> 输入：num = 8
> 输出：4
> 解释：
> 步骤 1） 8 是偶数，除以 2 得到 4 。
> 步骤 2） 4 是偶数，除以 2 得到 2 。
> 步骤 3） 2 是偶数，除以 2 得到 1 。
> 步骤 4） 1 是奇数，减 1 得到 0 。

示例 3：

> 输入：num = 123
> 输出：12


提示：

* 0 <= num <= 10^6

```c
int numberOfSteps(int num){
    int dp[num + 1];
    dp[0] = 0;

    for (int i = 1; i <= num; i++) {
        if (i % 2 == 0) {
            dp[i] = dp[i / 2] + 1;
        } else {
            dp[i] = dp[i - 1] + 1;
        }
    }
    return dp[num];
}
```

#### [剑指 Offer II 088. 爬楼梯的最少成本](https://leetcode.cn/problems/GzCJIP/)

数组的每个下标作为一个阶梯，第 i 个阶梯对应着一个非负数的体力花费值 cost[i]（下标从 0 开始）。

每当爬上一个阶梯都要花费对应的体力值，一旦支付了相应的体力值，就可以选择向上爬一个阶梯或者爬两个阶梯。

请找出达到楼层顶部的最低花费。在开始时，你可以选择从下标为 0 或 1 的元素作为初始阶梯。

 示例 1：

> 输入：cost = [10, 15, 20]
> 输出：15
> 解释：最低花费是从 cost[1] 开始，然后走两步即可到阶梯顶，一共花费 15 。

 示例 2：

> 输入：cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]
> 输出：6
> 解释：最低花费方式是从 cost[0] 开始，逐个经过那些 1 ，跳过 cost[3] ，一共花费 6 。


提示：

* 2 <= cost.length <= 1000
* 0 <= cost[i] <= 999

```c
int minCostClimbingStairs(int* cost, int costSize){
    int dp[costSize + 1];
    dp[0] = 0;
    dp[1] = 0;
    for (int i = 2; i <= costSize; i++) {
        dp[i] = fmin(dp[i - 1] + cost[i - 1], dp[i -2] + cost[i - 2]); 
    }
    return dp[costSize];
}
```

### 线性 dp

#### [198. 打家劫舍](https://leetcode.cn/problems/house-robber/)

你是一个专业的小偷，计划偷窃沿街的房屋。每间房内都藏有一定的现金，影响你偷窃的唯一制约因素就是相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警。

给定一个代表每个房屋存放金额的非负整数数组，计算你 不触动警报装置的情况下 ，一夜之内能够偷窃到的最高金额。

 示例 1：

> 输入：[1,2,3,1]
> 输出：4
> 解释：偷窃 1 号房屋 (金额 = 1) ，然后偷窃 3 号房屋 (金额 = 3)。
>      偷窃到的最高金额 = 1 + 3 = 4 。

示例 2：

> 输入：[2,7,9,3,1]
> 输出：12
> 解释：偷窃 1 号房屋 (金额 = 2), 偷窃 3 号房屋 (金额 = 9)，接着偷窃 5 号房屋 (金额 = 1)。
>      偷窃到的最高金额 = 2 + 9 + 1 = 12 。


提示：

* 1 <= nums.length <= 100
* 0 <= nums[i] <= 400

```c
int rob(int* nums, int numsSize){
    if (numsSize == 1) {
        return nums[0];
    }
    int dp[numsSize];
    dp[0] = nums[0];
    dp[1] = fmax(nums[0], nums[1]);

    for (int i = 2; i < numsSize; i++) {
        dp[i] = fmax(dp[i - 1], dp[i - 2] + nums[i]);
    }
    return dp[numsSize - 1];
}
```

#### [213. 打家劫舍 II](https://leetcode.cn/problems/house-robber-ii/)

你是一个专业的小偷，计划偷窃沿街的房屋，每间房内都藏有一定的现金。这个地方所有的房屋都 围成一圈 ，这意味着第一个房屋和最后一个房屋是紧挨着的。同时，相邻的房屋装有相互连通的防盗系统，如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警 。

给定一个代表每个房屋存放金额的非负整数数组，计算你 在不触动警报装置的情况下 ，今晚能够偷窃到的最高金额。

 示例 1：

> 输入：nums = [2,3,2]
> 输出：3
> 解释：你不能先偷窃 1 号房屋（金额 = 2），然后偷窃 3 号房屋（金额 = 2）, 因为他们是相邻的。

示例 2：

> 输入：nums = [1,2,3,1]
> 输出：4
> 解释：你可以先偷窃 1 号房屋（金额 = 1），然后偷窃 3 号房屋（金额 = 3）。
>      偷窃到的最高金额 = 1 + 3 = 4 。

示例 3：

> 输入：nums = [1,2,3]
> 输出：3


提示：

* 1 <= nums.length <= 100
* 0 <= nums[i] <= 1000

```c
int rob(int* nums, int numsSize){
    if (numsSize == 1) {
        return nums[0];
    }
    int dp[numsSize][2]; // 第二维 0 表示第 0 个元素选， 1 表示不选
    dp[0][0] = nums[0];
    dp[0][1] = 0;
    dp[1][0] = nums[0];
    dp[1][1] = nums[1];

    for (int i = 2; i < numsSize; i++) {
        for (int j = 0; j < 2; j++) {
            if (i == numsSize - 1 && j == 0) {
                dp[i][j] = dp[i - 1][j];
            } else {
                dp[i][j] = fmax(dp[i - 1][j], dp[i - 2][j] + nums[i]);
            }         
        }
        
    }
    return fmax(dp[numsSize - 1][0], dp[numsSize - 1][1]);
}
```

#### [91. 解码方法](https://leetcode.cn/problems/decode-ways/)

一条包含字母 A-Z 的消息通过以下映射进行了 编码 ：

> 'A' -> "1"
> 'B' -> "2"
> ...
> 'Z' -> "26"

要 解码 已编码的消息，所有数字必须基于上述映射的方法，反向映射回字母（可能有多种方法）。例如，"11106" 可以映射为：

*  "AAJF" ，将消息分组为 (1 1 10 6)
* "KJF" ，将消息分组为 (11 10 6)

注意，消息不能分组为  (1 11 06) ，因为 "06" 不能映射为 "F" ，这是由于 "6" 和 "06" 在映射中并不等价。

给你一个只含数字的 非空 字符串 s ，请计算并返回 解码 方法的 总数 。

题目数据保证答案肯定是一个 32 位 的整数。

示例 1：

> 输入：s = "12"
> 输出：2
> 解释：它可以解码为 "AB"（1 2）或者 "L"（12）。

示例 2：

> 输入：s = "226"
> 输出：3
> 解释：它可以解码为 "BZ" (2 26), "VF" (22 6), 或者 "BBF" (2 2 6) 。

示例 3：

> 输入：s = "0"
> 输出：0
> 解释：没有字符映射到以 0 开头的数字。
> 含有 0 的有效映射是 'J' -> "10" 和 'T'-> "20" 。
> 由于没有字符，因此没有有效的方法对此进行解码，因为所有数字都需要映射。


提示：

* 1 <= s.length <= 100
* s 只包含数字，并且可能包含前导零。

```c
int numDecodings(char * s){
    int len = strlen(s);
    int dp[len];
    memset(dp, 0, len * sizeof(int));

    dp[0] = s[0] == '0' ? 0 : 1;
    for (int i = 1; i < len; i++) {   
        if (s[i] != '0') {
            dp[i] += dp[i - 1];
        }
    
        int num = (s[i - 1] - '0') * 10 + (s[i] - '0');
        if (s[i - 1] != '0' && num <= 26) {  
            if (i == 1) {
                dp[i]++;
            } else {
                dp[i] += dp[i - 2];     
            }      
        }
    }
   
    return dp[len - 1];
}
```

#### [1646. 获取生成数组中的最大值](https://leetcode.cn/problems/get-maximum-in-generated-array/)

给你一个整数 n 。按下述规则生成一个长度为 n + 1 的数组 nums ：

nums[0] = 0
nums[1] = 1
当 2 <= 2 * i <= n 时，nums[2 * i] = nums[i]
当 2 <= 2 * i + 1 <= n 时，nums[2 * i + 1] = nums[i] + nums[i + 1]
返回生成数组 nums 中的 最大 值。

 示例 1：

> 输入：n = 7
> 输出：3
> 解释：根据规则：
>   nums[0] = 0
>   nums[1] = 1
>   nums[(1 * 2) = 2] = nums[1] = 1
>   nums[(1 * 2) + 1 = 3] = nums[1] + nums[2] = 1 + 1 = 2
>   nums[(2 * 2) = 4] = nums[2] = 1
>   nums[(2 * 2) + 1 = 5] = nums[2] + nums[3] = 1 + 2 = 3
>   nums[(3 * 2) = 6] = nums[3] = 2
>   nums[(3 * 2) + 1 = 7] = nums[3] + nums[4] = 2 + 1 = 3
> 因此，nums = [0,1,1,2,1,3,2,3]，最大值 3

示例 2：

> 输入：n = 2
> 输出：1
> 解释：根据规则，nums[0]、nums[1] 和 nums[2] 之中的最大值是 1

示例 3：

> 输入：n = 3
> 输出：2
> 解释：根据规则，nums[0]、nums[1]、nums[2] 和 nums[3] 之中的最大值是 2


提示：

* 0 <= n <= 100

```c
int getMaximumGenerated(int n){
    if (n == 0) {
        return 0;
    }
    int nums[n + 1];
    nums[0] = 0;
    nums[1] = 1;
    int maxNum = 1;

    for (int i = 1; i <= n; i++) {
        if (2 * i <= n) {
            nums[2 * i] = nums[i];
            if (maxNum < nums[2 * i]) {
                maxNum = nums[2 * i];
            }
        }
        if (2 * i + 1 <= n) {
            nums[2 * i + 1] = nums[i] + nums[i + 1];
            if (maxNum < nums[2 * i + 1]) {
                maxNum = nums[2 * i + 1];
            }
        }
    }
    return maxNum;
}
```

#### [1043. 分隔数组以得到最大和](https://leetcode.cn/problems/partition-array-for-maximum-sum/)

给你一个整数数组 arr，请你将该数组分隔为长度最多为 k 的一些（连续）子数组。分隔完成后，每个子数组的中的所有值都会变为该子数组中的最大值。

返回将数组分隔变换后能够得到的元素最大和。

 注意，原数组和分隔后的数组对应顺序应当一致，也就是说，你只能选择分隔数组的位置而不能调整数组中的顺序。

 示例 1：

> 输入：arr = [1,15,7,9,2,5,10], k = 3
> 输出：84
> 解释：
> 因为 k=3 可以分隔成 [1,15,7] [9] [2,5,10]，结果为 [15,15,15,9,10,10,10]，和为 84，是该数组所有分隔变换后元素总和最大的。
> 若是分隔成 [1] [15,7,9] [2,5,10]，结果就是 [1, 15, 15, 15, 10, 10, 10] 但这种分隔方式的元素总和（76）小于上一种。 

示例 2：

> 输入：arr = [1,4,1,5,7,3,6,1,9,9,3], k = 4
> 输出：83

示例 3：

> 输入：arr = [1], k = 1
> 输出：1


提示：

* 1 <= arr.length <= 500
* 0 <= arr[i] <= 109
* 1 <= k <= arr.length

```c
int maxSumAfterPartitioning(int* arr, int arrSize, int k){
    int dp[arrSize];
    memset(dp, 0, arrSize * sizeof(int));

    int maxV = 0;
    int cnt = 0;
    for (int i = 0; i < arrSize; i++) {
        maxV = 0;
        cnt = 0;
        for (int j = i; j >= 0; j--) {
            if (arr[j] > maxV) {
                maxV = arr[j];
            }
            cnt++;
            if (cnt > k) {
                break;
            }
            if (j > 0) {
                dp[i] = fmax(dp[i], dp[j - 1] + cnt * maxV);
            } else {
                dp[i] = fmax(dp[i], cnt * maxV);
            }
        }
    }
    return dp[arrSize - 1];
}
```

#### [139. 单词拆分](https://leetcode.cn/problems/word-break/)

给你一个字符串 s 和一个字符串列表 wordDict 作为字典。请你判断是否可以利用字典中出现的单词拼接出 s 。

注意：不要求字典中出现的单词全部都使用，并且字典中的单词可以重复使用。

 示例 1：

> 输入: s = "leetcode", wordDict = ["leet", "code"]
> 输出: true
> 解释: 返回 true 因为 "leetcode" 可以由 "leet" 和 "code" 拼接成。

示例 2：

> 输入: s = "applepenapple", wordDict = ["apple", "pen"]
> 输出: true
> 解释: 返回 true 因为 "applepenapple" 可以由 "apple" "pen" "apple" 拼接成。
>      注意，你可以重复使用字典中的单词。

示例 3：

> 输入: s = "catsandog", wordDict = ["cats", "dog", "sand", "and", "cat"]
> 输出: false


提示：

* 1 <= s.length <= 300
* 1 <= wordDict.length <= 1000
* 1 <= wordDict[i].length <= 20
* s 和 wordDict[i] 仅有小写英文字母组成
* wordDict 中的所有字符串 互不相同

```c
bool wordBreak(char * s, char ** wordDict, int wordDictSize){
    int len = strlen(s);
    int dp[len];
    memset(dp, 0, len * sizeof(int));

    for (int i = 0; i < len; i++) {
        for (int j = 0; j < wordDictSize; j++) {
            int lenOfWord = strlen(wordDict[j]);
            if (i - lenOfWord + 1 < 0) {
                continue;
            }
            if (i - lenOfWord > -1 && dp[i - lenOfWord] == 0) {
                continue;
            }
            int k;
            for (k = 0; k < lenOfWord; k++) {
                if (s[i - lenOfWord + k + 1] != wordDict[j][k]) {
                    break;
                }
            }
            if (k == lenOfWord) {
                dp[i] = 1;
                break;
            }
        }
    }
    return dp[len - 1];
}
```

#### [1869. 哪种连续子字符串更长](https://leetcode.cn/problems/longer-contiguous-segments-of-ones-than-zeros/)

给你一个二进制字符串 s 。如果字符串中由 1 组成的 最长 连续子字符串 严格长于 由 0 组成的 最长 连续子字符串，返回 true ；否则，返回 false 。

例如，s = "110100010" 中，由 1 组成的最长连续子字符串的长度是 2 ，由 0 组成的最长连续子字符串的长度是 3 。
注意，如果字符串中不存在 0 ，此时认为由 0 组成的最长连续子字符串的长度是 0 。字符串中不存在 1 的情况也适用此规则。

 示例 1：

> 输入：s = "1101"
> 输出：true
> 解释：
> 由 1 组成的最长连续子字符串的长度是 2："1101"
> 由 0 组成的最长连续子字符串的长度是 1："1101"
> 由 1 组成的子字符串更长，故返回 true 。

示例 2：

> 输入：s = "111000"
> 输出：false
> 解释：
> 由 1 组成的最长连续子字符串的长度是 3："111000"
> 由 0 组成的最长连续子字符串的长度是 3："111000"
> 由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。

示例 3：

> 输入：s = "110100010"
> 输出：false
> 解释：
> 由 1 组成的最长连续子字符串的长度是 2："110100010"
> 由 0 组成的最长连续子字符串的长度是 3："110100010"
> 由 1 组成的子字符串不比由 0 组成的子字符串长，故返回 false 。


提示：

* 1 <= s.length <= 100
* s[i] 不是 '0' 就是 '1'

```c
bool checkZeroOnes(char * s){
    int len = strlen(s);
    int dp[len][2];
    memset(dp, 0, sizeof(dp));
    
    dp[0][s[0] - '0'] = 1;
    int maxV[2] = {0, 0};
    maxV[s[0] - '0'] = 1;
    for (int i = 1; i < len; i++) {
        if (s[i] == s[i - 1]) {
            dp[i][s[i] - '0'] = dp[i - 1][s[i] - '0'] + 1;
        } else {
            dp[i][s[i] - '0'] = 1;
        }
        maxV[0] = fmax(maxV[0], dp[i][0]);
        maxV[1] = fmax(maxV[1], dp[i][1]);
    }
    return maxV[1] > maxV[0];
}
```

#### [724. 寻找数组的中心下标](https://leetcode.cn/problems/find-pivot-index/)

给你一个整数数组 nums ，请计算数组的 中心下标 。

数组 中心下标 是数组的一个下标，其左侧所有元素相加的和等于右侧所有元素相加的和。

如果中心下标位于数组最左端，那么左侧数之和视为 0 ，因为在下标的左侧不存在元素。这一点对于中心下标位于数组最右端同样适用。

如果数组有多个中心下标，应该返回 最靠近左边 的那一个。如果数组不存在中心下标，返回 -1 。

 示例 1：

> 输入：nums = [1, 7, 3, 6, 5, 6]
> 输出：3
> 解释：
> 中心下标是 3 。
> 左侧数之和 sum = nums[0] + nums[1] + nums[2] = 1 + 7 + 3 = 11 ，
> 右侧数之和 sum = nums[4] + nums[5] = 5 + 6 = 11 ，二者相等。

示例 2：

> 输入：nums = [1, 2, 3]
> 输出：-1
> 解释：
> 数组中不存在满足此条件的中心下标。

示例 3：

> 输入：nums = [2, 1, -1]
> 输出：0
> 解释：
> 中心下标是 0 。
> 左侧数之和 sum = 0 ，（下标 0 左侧不存在元素），
> 右侧数之和 sum = nums[1] + nums[2] = 1 + -1 = 0 。


提示：

* 1 <= nums.length <= 104
* -1000 <= nums[i] <= 1000

```c
int pivotIndex(int* nums, int numsSize){
    int sum[numsSize];
    memset(sum, 0, sizeof(sum));

    sum[0] = nums[0];
    for (int i = 1; i < numsSize; i++) {
        sum[i] = sum[i - 1] + nums[i];
    }

    if (sum[numsSize - 1] - sum[0] == 0) {
        return 0;
    }

    for (int i = 1; i < numsSize; i++) {
        if (sum[i - 1] == sum[numsSize - 1] - sum[i]) {
            return i;
        }
    }
    return -1;
}
```

